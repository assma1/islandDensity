```
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#gelman.diag(b, multivariate=FALSE)
```
###Cost analysis
Costs required to eradicate toads on Horan Island are based on the costs incurred during toad collection. We present costs as the cost of consumable, personal and travel costs (Table 1.).  Relative to most islands in Northern Australia, Horan island is readily accessible, thus our tavel costs are conservative.  Appendix 2 contains an itemized breakdown of costs (forthcoming). Sampling costs included equipment expenditure, survey time, and disposing of waste materials (i.e. toads). We assumed that the eradication is conducted by a fully-equipped organisation; hence we did not include costs for vehicle/boat purchase or hire (set-up costs).
Travel costs for removal included travelling to and from the site from Darwin, NT. We assume removal efforts are carried out on concurrent nights until eradication is reached, therefore travel costs were included only once. Travel costs are based on hourly rates elicited from personal correspondence (XXXX) and included a \$85 per hour consultant rate plus the additional cost of fuel, insurance, and vehicle maintenance (an extra \$36 per hour based on a per km charge). Thus, total travel costs are $111 per hour.
###Cost Scenarios
We extend our cost analysis to explore scenarios in order highlight the potential value of quarentine efforts across Northern Australia. Islands where taken from the Fedral Goverments 'prioritisation of high conservation status offshore islands' report. This report contains a list of the top 100 islands that the fedral goverment have prioritised for conservation due to thier biodiversity value and presence of species listed under the Environment Protection and Biodiversity Conservation Act. We filtered islands to include only those that were within the potential distribution of cane toads as modelled by Kearney et al. 2008. In additon, we furthur refined our dataset to exclude any island that is within 2km of the mainland shoreline or an established cane toad population. All islands were crossed checked with the 'Feral animals on offshore islands' database. In addition to the islands derived from the report(s), we explore the value of a 'mainland island', an area that is geographically isloated in such as way that the managment of a small wildlife corridoor allows it to be feasibly managed. The managment of this corridoor would, if effective, create a barrier to the spread of cane toads, allowing the formation of a mainland refuge of Xkm2. For furthur details see Tingley et al. 2012.
## Results (might combine some of the figures here or present as a table - thoughts?)
The number of individuals removed from Horan Island declined over time. Over the duration of our survey we encountered a total of 1251 cane toads (figure 2). Given the number of hours required to remove toads over each of our six removal bouts, our estimated detection probability is low (mean $p$ [95% credible interval] = 0.1[0.07, 0.13] (Figure 3). Taking into account our survey effort and estimated detection probaility, the model predicts that the number of animals present on Horan Island at the initiation of our surveys ($N_0$) was 2638 [2140, 3421] (Figure 4). Given that Horan Islands is 0.78km^2, the estimated density of cane toads per square kilometre is 3444 [2744, 4386].
With our estimates of $p$ and $\lambda$, we can examine the total survey effort (in days) required to eradicate toads from Horan Island. We envisage a successful eradication to have occurred when only a single toad remains (i.e no furthur breeding pairs remain). As we assume that removal efforts take place on consecutive nights until completion, we can disregarding breeding. Given our best estimate of $N_0$, we propose that leaving a single individual is equivalent to leaving $r_{crit}=\frac{1}{N_0}$ =  0.000379 of the original number of individuals. The time to reach this point is given by $\ln{r_{crit}}/\ln{(1-p)}=$  72 days. Given this estimate of days required to acheive eradication of cane toads on Horan Island, we multiply this againsy the estimated daily cost to run our mock eradication program to produce the estimated the cost required to remove toads from Horan island. We estimate it would cost \$AU77,670 to eradicate toads from Horan island, or estimated total cost of \$AU96,556 per km$^2$ of island.
###Cost scenarios
Given our estimated per km$^2$ cost of cane toad eradication, we begin to explore the remaining value of biosecurity across Australia. We estimate the potential remaining value of toad biosecurity efforts across northern Australia to be \$1,374,569,886 (derived from only toad free islands). This figure can furthur be broken down by state, island grouping or individual island (Appendix X). In addition we estimate the total budget required to clear toads from all offshore islands in Australia (\$415,151,033 - Appendix X). Whilst these figures may seem large, they likley underestimate the true value of biosecurity efforts due to inadvertant protection from additional invasives.
#Discussion
###Para 1: Islands are increasingly valuable as we move species onto them. Eradication $ estimate
Here we estimate the value of quarantine by exploring the expense of a subsequent eradication program (FIG X).  In doing so, we can begin to appreciate the value we gain from quarantine efforts. In the case of cane toads, Excitingly this idea can be extended to mainland islands, areas that are geographically isolated due to a combination of topography or climate. There is promising work being conducted on a mainland island in Northern Australia (REF). If successfully quarantined, this would halt the colonisation of the Pilbara, an area of 268,000km2, keeping toads out of a large swath of their potential range. Given our estimate of eradication per km2, and the impossibility of a successful eradication of toads from such an expanse, this represents a potential massive conservation gain.
###Para 2: The value of islands is lost if toads arrive. Density estimate
The value of an island is lost if cane toads arrive. Given the competitive ability and fecundity of cane toads, high population densities are likely to be realised immediately after colonisation. The need for quarantine measures is urgent, if there is a possibility of maintaining islands to receive endangered populations of natives in the future. Here we estimate that post-metamorph cane toads can reach an estimated density of 3441km2. This estimate is similar to density estimates derived from previous studies of invasive cane toads in the Solomon Islands archipelago (1035 individuals/km2) and the islands of Papua New Guinea (3000 individuals/km2). Despite this, our estimate is almost two orders of magnitude lower than the most commonly cited estimate of 2134 individuals per hectare (213,400km2). We are confident in a reduced estimate for two reasons; first our study only includes post-metamorph life stages, whereas the higher estimate of 213,400km2 was based on all life stages. Whilst metamorphs can occur at staggering densities (REF), these populations are often strongly constrained to the edges of waterbodies (Travis; Alford), and suffer high mortality from predation and desiccation post emergence (e.g. Ward-Fear; Pizatto). Secondly, given that cane toads disperse predominantly during the adult life stage, native fauna are likely to encounter (and predate) adult cane toads when first encountered. Given the high fatality rate upon consumption (REF; REF; REF), selective pressure is likely to be highest during this stage. Whilst informative, our estimate is derived from a population that is not limited by access to freshwater. Cane toads are inherently limited in thier ability to persist across on the landscape in areas where near-constant hydration is not possible (Florence et al.). Our non-water-limited estimate is likley to be applicable soley to areas where year round waterbodies persist, such as large natural catchments or structures engineered to house water year round.
###Para 3: Cost Scenarios
<!-- Given the renewed interest in islands as refugia for populations under threat from cane toad immigration, we can expect an increase in the number of species translocated to island refuges for conservation purposes. Such steps are already being taken in the Northern Territory, where translocations of northern quolls to Astell and Pobassoo island have been successfully carried out in order to provide insurance for mainland populations of the northern quoll (*Dasyurus hallucatus*) , a species which has declined drastically in rsponse to predation on cane toads. It is reasonable to expect that as islands become home to increasing numbers of insurance populations, or islands become a refuge for increasingly endangered species, their value will increase; as too will the loss incurred if cane toads manage to colonise them. Given that  -->
###Para 4: Insight into our detection prob. Concluding remarks
Our study provides an insight into the possible cost of cane toad eradication on an island, and thus, sharpens our sense of what quarantine is worth. Given the large sum spent each year on tactical management (i.e. spraying, culling) we believe the role of preventative management to be undervalued.This is particularly true when our ability to detect an established invader is low. Our estimated detection probability when removing cane toads by hand highlights the large amount out effort needed to remove even an isolated population. Given that detection estimates are likely to decline (with an increase in effort per individual removed) **not true; we have estimated individual-level detection** preventative management should be valued as a potential conservation tool. There are many instances of quarantine successfully halting the introduction of harmful species, although the cost savings are usually hard to quantify and preventative management is often undervalued to the detriment of conservation managers and the native landscape.
#References
I'll put these in when formatting properly.
Dawson et al. 2014
Cook et al. 2007
Simberloff 2013
Julia et al. 2007
Yemshanov et al. 2009
Burnett et al. 2008
Hoffman 2016
Wingate 2011
McKinney et al. unpublished data
TAB 2011)
Gelman & Rubin 1992a,b
Zugg et al. 1975
Pikacha et al. 2015
Freeland 1986
Ward-Fear et al. 2010
Shanmuganathan et al. 2010
Nakajima et al. 2005
Burbidge et al. (2018)
Zhang & Gu 1998
```{r, echo=FALSE, message=FALSE, warning=FALSE, results = 'asis'}
library(knitr)
#area (km^2) * cost per km^2
ConsumCost <- '$5,611' #cost per km^2 to eradicate in AU
PersonCost <- '$61,200'
TravelCost <- '$9,768'
costData <- matrix(c(ConsumCost, PersonCost, TravelCost))
colnames (costData) <- c("Cost (AU)")
rownames (costData) <- c( "Consumable Cost", "Personal Cost", "Travel Cost")
costData <- as.table(costData)
kable(costData, caption = "Table: Estimated costs incurred from toad eradication program on Horan Island") #%>%
#kable_styling(bootstrap_options = "striped", full_width = F, position = "float_right")
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, results = 'asis'}
library(kableExtra)
#area (km^2) * cost per km^2
KiloCost <- '$98,569' #cost per km^2 to eradicate in AU
HoranIsland <- '$76,579'
WAabsent <- '$112,578,720'
NTabsent <- '$1,037,843,083'
NTpresent <- '$121,443,116'
QLDabsent <- '$224,148,083'
QLDpresent <-  '$293,707,917'
Pilbarra <- '$26,416,748,616'
costData <- matrix(c(KiloCost, HoranIsland, WAabsent, NTabsent, NTpresent, QLDabsent, QLDpresent, Pilbarra))
colnames (costData) <- c("Cost to Eradicate toads (AU)")
rownames (costData) <- c( "Cost per Km^2^", "Horan Island", "WA islands (toad free)", "NT islands (toads present)", "NT islands (toad free)", "QLD islands (toads present)", "QLD islands (toad free)", "Pilbarra refuge")
costData <- as.table(costData)
kable(costData, caption = "Value of Biosecurity measures in Northern Australia in AU")
```
```{r, echo=FALSE, message=FALSE, warning=FALSE,fig.cap=cap1, fig.height=3, message=FALSE, warning=FALSE, fid.width=3, fig.align= 'cente'}
library(knitr)
opts_knit$set(eval.after = 'fig.cap')
cap1 <- "Number of individuals collected per sampling night"
plot(ct~t, xlab="Collection bout", ylab="Number of toads removed", bty="l", cex=1.5, pch=21, bg=16, ylim=c(95, max(ct)))
```
```{r, echo=FALSE, message=FALSE, warning=FALSE}
bComb<-do.call(what = "rbind", args = b)
meanP<-mean(bComb[,"p"])
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap=cap2, fig.height=3, message=FALSE, warning=FALSE, fid.width=3, fig.align= 'cente'}
library(knitr)
opts_knit$set(eval.after = 'fig.cap')
cap2 <- "Estimated detection probability after t=6 bouts of removal"
plot(density(bComb[,"p"]), main = "", xlab="Estimated detection probbaility", ylab="Density", bty="l")
```
```{r, echo = FALSE}
meanLam<-mean(bComb[,"lambda"])
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap=cap3, fig.height=3, message=FALSE, warning=FALSE, fid.width=3, fig.align= 'cente'}
library(knitr)
opts_knit$set(eval.after = 'fig.cap')
cap3 <- "Estimated population size at initiation of removal efforts."
plot(density(bComb[,"lambda"]), main = "", xlab="Estimated population size at t=0", ylab="Density")
```
\
\
\
\
\
#Data exploration
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(DT)
toadCosting <- read.csv("~/Desktop/toadCosting.csv", header=TRUE)
datatable(toadCosting, class = 'cell-border stripe')
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap=cap3, fig.height=3, message=FALSE, warning=FALSE, fid.width=3, fig.align= 'cente'}
#Required libraries
library(rjags)
library(coda)
#Input of removal data from S1
t<-0:5
ct<-c(247, 192, 274, 286, 129, 123)
nrows<-length(ct)
sumct<-c(0, cumsum(ct)[-nrows])
#Bring in the removal model
a<-jags.model(file="../../Fieldwork/toadRemoval/scripts/removalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
```{r, echo=FALSE}
#Required libraries
library(rjags)
library(coda)
#Input of removal data from S1
t<-0:5
ct<-c(247, 192, 274, 286, 129, 123)
nrows<-length(ct)
sumct<-c(0, cumsum(ct)[-nrows])
#Bring in the removal model
a<-jags.model(file="../../Fieldwork/toadRemoval/scripts/removalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
traitData <- read.csv("~/Dropbox/Adam PhD/Coding Club/BES Workshop/Data/traitdata.csv")
View(traitData)
knitr::opts_chunk$set(echo = FALSE)
traitData <- read.csv("~/Dropbox/Adam PhD/Coding Club/BES Workshop/Data/traitdata.csv")
head(traitData)
View(traitData)
str(data_set)
str(traitData)
View(traitData)
str(traitData)
?which()
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
View(recapData)
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
View(t_remov)
head(recapData)
head(t_remov)
str(recapData)
recapData <- recapData([0,2:6])
recapData <- recapData(c[0,2:6])
recapData <- subset(c[0,2:6])
recapData <- subset([0,2:6])
View(recapData)
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[myvars]
recapData <- recapData[vars]
View(recapData)
?rbind
t_remov <- c("toadID", "remove_T", "O")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
t_remov_vars <- c("toadID", "remove_T", "O")
t_remov <- t_remov[t_remov_vars]
t_remov <- t_remov[t_remov_vars]
t_remov["O"] <- NA
View(t_remov)
t_remov["O"] <- if(t_remov[remov_T=1000,0,1])
t_remov["O"] <- if(t_remov[remov_T=1000,0,1])
t_remov["O"] <- if(t_remov[remov_T=1000,0,1])
recapData <- recapData[vars]
t_remov["O"] <- if(t_remov[remov_T=1000,0,1])
View(t_remov)
?if
?if
?if
View(t_remov)
View(t_remov)
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
###Loac in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
head(recapData)
head(t_remov)
str(recapData)
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
View(t_remov)
###Loac in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
head(recapData)
head(t_remov)
str(recapData)
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
View(t_remov)
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
View(t_remov)
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
###Loac in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
View(t_remov)
library(rjags)
library(coda)
recapMod<-jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
nSess=3
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
maxTime=114
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
N_A=10000
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
?quiet
?quiet
###Load in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
####Req libraries####
library(rjags)
library(coda)
###Variable state###
nSess=3
maxTime=114
N_A=10000
TN_Q=45
TN_L=30
TN_F=5
###Load in and run model###
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
update(a, n.iter=30000)
b<-coda.samples(a, c("p", "lambda"),
thin =2, n.iter=10000, quiet=TRUE)
###Load in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
####Req libraries####
library(rjags)
library(coda)
###Variable state###
nSess=3
maxTime=114
N_A=10000
TN_Q=45
TN_L=30
TN_F=5
###Load in and run model###
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
update(a, n.iter=30000)
b<-coda.samples(a, c("p", "lambda"),
thin =2, n.iter=10000, quiet=TRUE)
###Load in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
####Req libraries####
library(rjags)
library(coda)
###Variable state###
nSess=3
maxTime=114
N_A=10000
TN_Q=45
TN_L=30
TN_F=5
###Load in and run model###
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
update(a, n.iter=30000)
b<-coda.samples(a, c("p", "lambda"),
thin =2, n.iter=10000, quiet=TRUE)
###Load in data###
recapData <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/recapData.csv")
t_remov <- read.csv("~/Dropbox/HoranMarkRecap/dat/raw/t_remov.csv")
vars <- c("t", "sessID", "A_u", "A_m", "A_q", "A_f")
recapData <- recapData[vars]
####Req libraries####
library(rjags)
library(coda)
###Variable state###
nSess=3
maxTime=114
N_A=10000
TN_Q=45
TN_L=30
TN_F=5
###Load in and run model###
recapMod <- jags.model(file="/Users/adamsmart/Dropbox/HoranMarkRecap/src/markRecapRemovalModel.txt",
n.chains=3,
data=environment(), quiet=TRUE)
update(recapMod, n.iter=30000)
b<-coda.samples(recapMod, c("p", "lambda"),
thin =2, n.iter=10000, quiet=TRUE)
View(recapData)
View(t_remov)
library("rjags", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
?put
?get
put?
?put
#--------------------------Figure output
plot(ct~t, xlab="Collection bout", ylab="Number of toads removed", bty="l", cex=1.5, pch=21, bg=16, ylim=c(95, max(ct)))
x <- 1:10
y <- c(0.1, 1, 10)
p1<-plot(x, y, type=“l”, ylim=c(0,1), bty=“l”,
frame.plot=TRUE, xlab=“”, ylab=“”, axes=FALSE, main= “Hetrogeneous”)
x <- 1:10
y <- c(0.1, 1, 10)
p1<-plot(x, y, type=“l”, ylim=c(0,1), bty=“l”,
frame.plot=TRUE, xlab=“”, ylab=“”, axes=FALSE, main= “Hetrogeneous”)
p1<-plot(x, y, type=“l”, ylim=c(0,1), bty=“l”,
frame.plot=TRUE, xlab=“”, ylab=“”, axes=FALSE, main= “Hetrogeneous”)
install.packages("swirl")
library("swirl")
install_course("Course Name Here")
install.packages("swirl")
install.packages("swirl")
library("swirl")
swirl::install_course("R Programming")
swirl()
swirl()
112578+1037843083+121443116+224148083+293707917
install.packages(“swirl”)
library(“swirl”)
swirl::install_course(“R Programming”)
swirl()
install.packages(“swirl”)
library(“swirl”)
install.packages(“swirl”)
install.packages('swirl')
install.packages('swirl')
library('swirl')
swirl::install_course('R Programming')
library("dplyr", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
library(dplyr)
(meanP<-mean(bComb[,"p"])) #mean detection probability
2/6
knitr::opts_chunk$set(echo = TRUE)
pop
rm(list=ls())
## Demographic and evolutionary parameters
nLoci<-20 #number of loci
initFreq<-0.5 #frequency of genes
Rmax<-5 #maximum reproductive rate per generation
Nstar<-500 #Number of starting individuals
n<-Nstar
mu<-log(2) # log mean dispersal distance (at init)
VT<-log(1.5)^2 # Total variance in di
h2<-0.3 #heretability - set to 0.3
Vg<-h2*VT
Ve<-(1-h2)*VT
eSize<-sqrt((Vg)/((2*nLoci)*initFreq*(1-initFreq)))
k<-0.2
initGens<- 100 #generations to run the simulation over
# Initialises the simulation
init<-function(n, nLoci, eSize, Ve, mu, maxX=1){
X<-runif(n, 0, maxX) #distribution with min 0 and max = maxX
alleles<-matrix(rbinom(2*n*nLoci, 1, 0.5), nrow=n,  #matrix of alleles (0,1 - prob 50%)
dimnames=list(NULL, paste("a", 1:(2*nLoci), sep=""))) #headings for allele matrix
pop<-cbind(X, alleles, di=rep(0, n)) #population matrix
pop<-dPhen(pop, eSize, Ve, nLoci, mu) #dPhen is dispersal phentoype based on the below
pop
}
# Calculates dispersal phenotype based on individual alleles, their effect, and Ve
dPhen<-function(pop, eSize, Ve, nLoci, mu){
gtypes<-pop[,grepl("a", colnames(pop))] #replace colnames names
gtypes<-apply(gtypes, 1, sum)*eSize-(nLoci*2*0.5*eSize)+mu #sums dataset gtypes to '1', multiply by eSize and add 'mu'
ptypes<-rnorm(length(gtypes), mean=gtypes, sd=sqrt(Ve)) #transform genotype to phenotype
pop[,"di"]<-ptypes #guessing di is chance/distance of dispersal?
pop
}
# returns alpha of the BevHolt function - #Beverton–Holt model is a classic discrete-time population model which gives the expected number n t+1 (or density) of individuals in generation t + 1 as a function of the number of individuals in the previous generation
tOff<-function(Rmax, Nstar, di, k){  #rmax is growth rate, Nstar is starting inds, di = dispersal phenotype, k is carry cap here.
(Rmax-1)/(Nstar*exp(-k*exp(di)))
}
# Beverton Holt population growth
bevHolt<-function(N, Rmax, Nstar, a){
#a<-(Rmax-1)/Nstar
Rmax/(1+a*N)
}
#Generates gametes for an individual
gametes<-function(poprow){
orderlist<-c(seq(1, 2*nLoci, 2), seq(2, 2*nLoci, 2))
gtypes<-poprow[grepl("a", names(poprow))]
temp<-rbinom(nLoci, 1, 0.5)
temp<-c(temp, temp!=1)[order(orderlist)]
gametes<-gtypes[temp==1]
gametes
}
# Reproduces individuals, with inheritance.
reproduce<-function(pop, Rmax, Nstar, nLoci, eSize, Ve, k, mu){
orderlist<-order(c(seq(1, 2*nLoci, 2), seq(2, 2*nLoci, 2)))
alpha<-tOff(Rmax, Nstar,pop[,"di"], k)
EW<-bevHolt(dens(pop), Rmax, Nstar, alpha)
W<-rpois(length(EW), EW)
gtype.loc<-grepl("a", colnames(pop))
pop2<-matrix(NA, nrow=sum(W), ncol=ncol(pop), dimnames=dimnames(pop))
offInd<-1
for (ii in 1:nrow(pop)){
if (W[ii]==0) next
for (ww in 1:W[ii]){
temp<-pop[ii,]
tempF<-temp
popSet<-which((pop[,"X"] %/% 1) == (tempF["X"] %/% 1))
tempM<-pop[sample(popSet, 1),]
temp[gtype.loc]<-c(gametes(tempF), gametes(tempM))[orderlist]
pop2[offInd,]<-temp
offInd<-offInd+1
}
}
pop<-dPhen(pop2, eSize, Ve, nLoci, mu)
pop
}
# runs basic spread model
run.sim<-function(n, nLoci, eSize, Rmax, Nstar, k, initGens, Ve, mu){
pop<-init(n, nLoci, eSize, Ve, mu)
N<-nrow(pop)
mean.di<-mean(pop[,"di"])
X.g<-var(pop[,"X"])
X.max<-max(pop[,"X"])
for (gg in 1:initGens){
# cat("Working through generation ", gg, "\n")
pop<-reproduce(pop, Rmax, Nstar, nLoci, eSize, Ve, k, mu)
N<-c(N, nrow(pop))
mean.di<-c(mean.di, mean(pop[,"di"]))
X.g<-c(X.g, var(pop[,"X"]))
X.max<-c(X.max, max(pop[,"X"]))
}
list(N=N, mean.di=mean.di, X.g=X.g, X.max=X.max, pop=pop)
}
# calculates density back to the individual
dens<-function(pop){
Xbin<-(pop[,"X"] %/% 1)+1
dens<-table(factor(Xbin, levels=1:max(Xbin)))
dens[Xbin]
}
temp <-run.sim(n=n,
nLoci=nLoci,
eSize=eSize,
Rmax=Rmax,
Nstar=Nstar,
k=k,
initGens=initGens,
Ve=Ve,
mu=mu)
#install.packages("profvis")
# library(profvis)
# profvis(test<-run.sim(n=n,
#                       nLoci=nLoci,
#                       eSize=eSize,
#                       Rmax=Rmax,
#                       Nstar=Nstar,
#                       k=k,
#                       initGens=initGens,
#                       Ve=Ve,
#                       mu=mu))
# Notes: profile reveals most time consuming thing is generating gametes.
plot(temp$N, xlab ='Generation', ylab = 'Number of individuals', type = "l")
plot(temp$mean.di, xlab = 'Generation', ylab = 'Frequency of high dispersal trait at each locus', type="l")
pop
View(init)
setwd("~/Dropbox/Adam PhD/manuscripts/islandDensity/src")
install.packages("kableExtra")
library("kableExtra", lib.loc="~/Library/R/3.4/library")
#raw number of removals per night
horan<- data.frame(x= removalData$removalNight, y = removalData$removalNumbers[1:6])
set.seed(1000)
#clear workspace
rm(list=ls())
#assign required packages
pkgs = c("rjags", "coda", "knitr", "ggplot2", "dplyr", "gridExtra", "scales", "readxl", "gdata", "RColorBrewer", "ggridges", "reshape2")
#check if required packages are installed, if not - install
new.pkgs <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
if(length(new.pkgs)) install.packages(new.pkgs)
#load packages
inst = lapply(pkgs, library, character.only = TRUE)
#load in relevant datasets
removalData<- read_excel("dat/removalData.xlsx", sheet = "removal") #Number of individuals removed each night
costData<- read_excel("dat/costData.xlsx", sheet = "sumCost") #cost data from field removal
areaData<- read_excel("dat/costData.xlsx", sheet = "sumArea", col_types = c("text", "numeric", "numeric")) #island area data from goverment databases
